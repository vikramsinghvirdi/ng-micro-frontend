{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar t;\n\nconst i = window,\n      s = i.trustedTypes,\n      e = s ? s.createPolicy(\"lit-html\", {\n  createHTML: t => t\n}) : void 0,\n      o = `lit$${(Math.random() + \"\").slice(9)}$`,\n      n = \"?\" + o,\n      l = `<${n}>`,\n      h = document,\n      r = (t = \"\") => h.createComment(t),\n      d = t => null === t || \"object\" != typeof t && \"function\" != typeof t,\n      u = Array.isArray,\n      c = t => u(t) || \"function\" == typeof (null == t ? void 0 : t[Symbol.iterator]),\n      v = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g,\n      a = /-->/g,\n      f = />/g,\n      _ = RegExp(\">|[ \\t\\n\\f\\r](?:([^\\\\s\\\"'>=/]+)([ \\t\\n\\f\\r]*=[ \\t\\n\\f\\r]*(?:[^ \\t\\n\\f\\r\\\"'`<>=]|(\\\"|')|))|$)\", \"g\"),\n      m = /'/g,\n      p = /\"/g,\n      $ = /^(?:script|style|textarea|title)$/i,\n      g = t => (i, ...s) => ({\n  _$litType$: t,\n  strings: i,\n  values: s\n}),\n      y = g(1),\n      w = g(2),\n      x = Symbol.for(\"lit-noChange\"),\n      b = Symbol.for(\"lit-nothing\"),\n      T = new WeakMap(),\n      A = (t, i, s) => {\n  var e, o;\n  const n = null !== (e = null == s ? void 0 : s.renderBefore) && void 0 !== e ? e : i;\n  let l = n._$litPart$;\n\n  if (void 0 === l) {\n    const t = null !== (o = null == s ? void 0 : s.renderBefore) && void 0 !== o ? o : null;\n    n._$litPart$ = l = new S(i.insertBefore(r(), t), t, void 0, null != s ? s : {});\n  }\n\n  return l._$AI(t), l;\n},\n      E = h.createTreeWalker(h, 129, null, !1),\n      C = (t, i) => {\n  const s = t.length - 1,\n        n = [];\n  let h,\n      r = 2 === i ? \"<svg>\" : \"\",\n      d = v;\n\n  for (let i = 0; i < s; i++) {\n    const s = t[i];\n    let e,\n        u,\n        c = -1,\n        g = 0;\n\n    for (; g < s.length && (d.lastIndex = g, u = d.exec(s), null !== u);) g = d.lastIndex, d === v ? \"!--\" === u[1] ? d = a : void 0 !== u[1] ? d = f : void 0 !== u[2] ? ($.test(u[2]) && (h = RegExp(\"</\" + u[2], \"g\")), d = _) : void 0 !== u[3] && (d = _) : d === _ ? \">\" === u[0] ? (d = null != h ? h : v, c = -1) : void 0 === u[1] ? c = -2 : (c = d.lastIndex - u[2].length, e = u[1], d = void 0 === u[3] ? _ : '\"' === u[3] ? p : m) : d === p || d === m ? d = _ : d === a || d === f ? d = v : (d = _, h = void 0);\n\n    const y = d === _ && t[i + 1].startsWith(\"/>\") ? \" \" : \"\";\n    r += d === v ? s + l : c >= 0 ? (n.push(e), s.slice(0, c) + \"$lit$\" + s.slice(c) + o + y) : s + o + (-2 === c ? (n.push(void 0), i) : y);\n  }\n\n  const u = r + (t[s] || \"<?>\") + (2 === i ? \"</svg>\" : \"\");\n  if (!Array.isArray(t) || !t.hasOwnProperty(\"raw\")) throw Error(\"invalid template strings array\");\n  return [void 0 !== e ? e.createHTML(u) : u, n];\n};\n\nclass P {\n  constructor({\n    strings: t,\n    _$litType$: i\n  }, e) {\n    let l;\n    this.parts = [];\n    let h = 0,\n        d = 0;\n    const u = t.length - 1,\n          c = this.parts,\n          [v, a] = C(t, i);\n\n    if (this.el = P.createElement(v, e), E.currentNode = this.el.content, 2 === i) {\n      const t = this.el.content,\n            i = t.firstChild;\n      i.remove(), t.append(...i.childNodes);\n    }\n\n    for (; null !== (l = E.nextNode()) && c.length < u;) {\n      if (1 === l.nodeType) {\n        if (l.hasAttributes()) {\n          const t = [];\n\n          for (const i of l.getAttributeNames()) if (i.endsWith(\"$lit$\") || i.startsWith(o)) {\n            const s = a[d++];\n\n            if (t.push(i), void 0 !== s) {\n              const t = l.getAttribute(s.toLowerCase() + \"$lit$\").split(o),\n                    i = /([.?@])?(.*)/.exec(s);\n              c.push({\n                type: 1,\n                index: h,\n                name: i[2],\n                strings: t,\n                ctor: \".\" === i[1] ? R : \"?\" === i[1] ? H : \"@\" === i[1] ? I : M\n              });\n            } else c.push({\n              type: 6,\n              index: h\n            });\n          }\n\n          for (const i of t) l.removeAttribute(i);\n        }\n\n        if ($.test(l.tagName)) {\n          const t = l.textContent.split(o),\n                i = t.length - 1;\n\n          if (i > 0) {\n            l.textContent = s ? s.emptyScript : \"\";\n\n            for (let s = 0; s < i; s++) l.append(t[s], r()), E.nextNode(), c.push({\n              type: 2,\n              index: ++h\n            });\n\n            l.append(t[i], r());\n          }\n        }\n      } else if (8 === l.nodeType) if (l.data === n) c.push({\n        type: 2,\n        index: h\n      });else {\n        let t = -1;\n\n        for (; -1 !== (t = l.data.indexOf(o, t + 1));) c.push({\n          type: 7,\n          index: h\n        }), t += o.length - 1;\n      }\n\n      h++;\n    }\n  }\n\n  static createElement(t, i) {\n    const s = h.createElement(\"template\");\n    return s.innerHTML = t, s;\n  }\n\n}\n\nfunction V(t, i, s = t, e) {\n  var o, n, l, h;\n  if (i === x) return i;\n  let r = void 0 !== e ? null === (o = s._$Cl) || void 0 === o ? void 0 : o[e] : s._$Cu;\n  const u = d(i) ? void 0 : i._$litDirective$;\n  return (null == r ? void 0 : r.constructor) !== u && (null === (n = null == r ? void 0 : r._$AO) || void 0 === n || n.call(r, !1), void 0 === u ? r = void 0 : (r = new u(t), r._$AT(t, s, e)), void 0 !== e ? (null !== (l = (h = s)._$Cl) && void 0 !== l ? l : h._$Cl = [])[e] = r : s._$Cu = r), void 0 !== r && (i = V(t, r._$AS(t, i.values), r, e)), i;\n}\n\nclass N {\n  constructor(t, i) {\n    this.v = [], this._$AN = void 0, this._$AD = t, this._$AM = i;\n  }\n\n  get parentNode() {\n    return this._$AM.parentNode;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  p(t) {\n    var i;\n    const {\n      el: {\n        content: s\n      },\n      parts: e\n    } = this._$AD,\n          o = (null !== (i = null == t ? void 0 : t.creationScope) && void 0 !== i ? i : h).importNode(s, !0);\n    E.currentNode = o;\n    let n = E.nextNode(),\n        l = 0,\n        r = 0,\n        d = e[0];\n\n    for (; void 0 !== d;) {\n      if (l === d.index) {\n        let i;\n        2 === d.type ? i = new S(n, n.nextSibling, this, t) : 1 === d.type ? i = new d.ctor(n, d.name, d.strings, this, t) : 6 === d.type && (i = new L(n, this, t)), this.v.push(i), d = e[++r];\n      }\n\n      l !== (null == d ? void 0 : d.index) && (n = E.nextNode(), l++);\n    }\n\n    return o;\n  }\n\n  m(t) {\n    let i = 0;\n\n    for (const s of this.v) void 0 !== s && (void 0 !== s.strings ? (s._$AI(t, s, i), i += s.strings.length - 2) : s._$AI(t[i])), i++;\n  }\n\n}\n\nclass S {\n  constructor(t, i, s, e) {\n    var o;\n    this.type = 2, this._$AH = b, this._$AN = void 0, this._$AA = t, this._$AB = i, this._$AM = s, this.options = e, this._$C_ = null === (o = null == e ? void 0 : e.isConnected) || void 0 === o || o;\n  }\n\n  get _$AU() {\n    var t, i;\n    return null !== (i = null === (t = this._$AM) || void 0 === t ? void 0 : t._$AU) && void 0 !== i ? i : this._$C_;\n  }\n\n  get parentNode() {\n    let t = this._$AA.parentNode;\n    const i = this._$AM;\n    return void 0 !== i && 11 === t.nodeType && (t = i.parentNode), t;\n  }\n\n  get startNode() {\n    return this._$AA;\n  }\n\n  get endNode() {\n    return this._$AB;\n  }\n\n  _$AI(t, i = this) {\n    t = V(this, t, i), d(t) ? t === b || null == t || \"\" === t ? (this._$AH !== b && this._$AR(), this._$AH = b) : t !== this._$AH && t !== x && this.$(t) : void 0 !== t._$litType$ ? this.T(t) : void 0 !== t.nodeType ? this.k(t) : c(t) ? this.O(t) : this.$(t);\n  }\n\n  S(t, i = this._$AB) {\n    return this._$AA.parentNode.insertBefore(t, i);\n  }\n\n  k(t) {\n    this._$AH !== t && (this._$AR(), this._$AH = this.S(t));\n  }\n\n  $(t) {\n    this._$AH !== b && d(this._$AH) ? this._$AA.nextSibling.data = t : this.k(h.createTextNode(t)), this._$AH = t;\n  }\n\n  T(t) {\n    var i;\n    const {\n      values: s,\n      _$litType$: e\n    } = t,\n          o = \"number\" == typeof e ? this._$AC(t) : (void 0 === e.el && (e.el = P.createElement(e.h, this.options)), e);\n    if ((null === (i = this._$AH) || void 0 === i ? void 0 : i._$AD) === o) this._$AH.m(s);else {\n      const t = new N(o, this),\n            i = t.p(this.options);\n      t.m(s), this.k(i), this._$AH = t;\n    }\n  }\n\n  _$AC(t) {\n    let i = T.get(t.strings);\n    return void 0 === i && T.set(t.strings, i = new P(t)), i;\n  }\n\n  O(t) {\n    u(this._$AH) || (this._$AH = [], this._$AR());\n    const i = this._$AH;\n    let s,\n        e = 0;\n\n    for (const o of t) e === i.length ? i.push(s = new S(this.S(r()), this.S(r()), this, this.options)) : s = i[e], s._$AI(o), e++;\n\n    e < i.length && (this._$AR(s && s._$AB.nextSibling, e), i.length = e);\n  }\n\n  _$AR(t = this._$AA.nextSibling, i) {\n    var s;\n\n    for (null === (s = this._$AP) || void 0 === s || s.call(this, !1, !0, i); t && t !== this._$AB;) {\n      const i = t.nextSibling;\n      t.remove(), t = i;\n    }\n  }\n\n  setConnected(t) {\n    var i;\n    void 0 === this._$AM && (this._$C_ = t, null === (i = this._$AP) || void 0 === i || i.call(this, t));\n  }\n\n}\n\nclass M {\n  constructor(t, i, s, e, o) {\n    this.type = 1, this._$AH = b, this._$AN = void 0, this.element = t, this.name = i, this._$AM = e, this.options = o, s.length > 2 || \"\" !== s[0] || \"\" !== s[1] ? (this._$AH = Array(s.length - 1).fill(new String()), this.strings = s) : this._$AH = b;\n  }\n\n  get tagName() {\n    return this.element.tagName;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  _$AI(t, i = this, s, e) {\n    const o = this.strings;\n    let n = !1;\n    if (void 0 === o) t = V(this, t, i, 0), n = !d(t) || t !== this._$AH && t !== x, n && (this._$AH = t);else {\n      const e = t;\n      let l, h;\n\n      for (t = o[0], l = 0; l < o.length - 1; l++) h = V(this, e[s + l], i, l), h === x && (h = this._$AH[l]), n || (n = !d(h) || h !== this._$AH[l]), h === b ? t = b : t !== b && (t += (null != h ? h : \"\") + o[l + 1]), this._$AH[l] = h;\n    }\n    n && !e && this.P(t);\n  }\n\n  P(t) {\n    t === b ? this.element.removeAttribute(this.name) : this.element.setAttribute(this.name, null != t ? t : \"\");\n  }\n\n}\n\nclass R extends M {\n  constructor() {\n    super(...arguments), this.type = 3;\n  }\n\n  P(t) {\n    this.element[this.name] = t === b ? void 0 : t;\n  }\n\n}\n\nconst k = s ? s.emptyScript : \"\";\n\nclass H extends M {\n  constructor() {\n    super(...arguments), this.type = 4;\n  }\n\n  P(t) {\n    t && t !== b ? this.element.setAttribute(this.name, k) : this.element.removeAttribute(this.name);\n  }\n\n}\n\nclass I extends M {\n  constructor(t, i, s, e, o) {\n    super(t, i, s, e, o), this.type = 5;\n  }\n\n  _$AI(t, i = this) {\n    var s;\n    if ((t = null !== (s = V(this, t, i, 0)) && void 0 !== s ? s : b) === x) return;\n    const e = this._$AH,\n          o = t === b && e !== b || t.capture !== e.capture || t.once !== e.once || t.passive !== e.passive,\n          n = t !== b && (e === b || o);\n    o && this.element.removeEventListener(this.name, this, e), n && this.element.addEventListener(this.name, this, t), this._$AH = t;\n  }\n\n  handleEvent(t) {\n    var i, s;\n    \"function\" == typeof this._$AH ? this._$AH.call(null !== (s = null === (i = this.options) || void 0 === i ? void 0 : i.host) && void 0 !== s ? s : this.element, t) : this._$AH.handleEvent(t);\n  }\n\n}\n\nclass L {\n  constructor(t, i, s) {\n    this.element = t, this.type = 6, this._$AN = void 0, this._$AM = i, this.options = s;\n  }\n\n  get _$AU() {\n    return this._$AM._$AU;\n  }\n\n  _$AI(t) {\n    V(this, t);\n  }\n\n}\n\nconst z = {\n  A: \"$lit$\",\n  M: o,\n  C: n,\n  L: 1,\n  R: C,\n  D: N,\n  V: c,\n  I: V,\n  H: S,\n  N: M,\n  U: H,\n  B: I,\n  F: R,\n  W: L\n},\n      Z = i.litHtmlPolyfillSupport;\nnull == Z || Z(P, S), (null !== (t = i.litHtmlVersions) && void 0 !== t ? t : i.litHtmlVersions = []).push(\"2.3.1\");\nexport { z as _$LH, y as html, x as noChange, b as nothing, A as render, w as svg }; //# sourceMappingURL=lit-html.js.map","map":null,"metadata":{},"sourceType":"module"}